{"name": "test_queue_update_event", "status": "broken", "statusDetails": {"message": "socketio.exceptions.ConnectionError: One or more namespaces failed to connect", "trace": "env_config = EnvConfig(scheme='http', host='localhost', port=8081, base_path='', robot_id='arm1', user_id='1001047', token='QhZewTLifPlcp8I01ZFwCND7F1lKOolpFlbq1fdNA0s')\n\n    @pytest.fixture(scope=\"function\")\n    def socketio_client(env_config: EnvConfig):\n        \"\"\"\n        Connect to Socket.IO of tele-op backend and yield (client, collector).\n        Requires USER_ID and TOKEN to be valid for the backend DB.\n        \"\"\"\n        if not env_config.user_id or not env_config.token:\n            pytest.skip(\"USER_ID and TOKEN must be provided via env vars to run Socket.IO tests\")\n    \n        server_url = env_config.base_url\n        collector = QueueEventCollector()\n        sio = socketio.Client(reconnection=True, reconnection_attempts=0, logger=False, engineio_logger=False)\n    \n        @sio.event\n        def connect():\n            logger.info(\"Connected sid=%s\", getattr(sio, \"sid\", None))\n    \n        @sio.event\n        def disconnect():\n            logger.info(\"Disconnected from server\")\n    \n        @sio.event\n        def connect_error(data):\n            try:\n                pretty = json.dumps(data, ensure_ascii=False)\n            except Exception:\n                pretty = str(data)\n            logger.error(\"connect_error: %s\", pretty)\n    \n        @sio.on(\"queue_update\")\n        def on_queue_update(data):\n            try:\n                pretty = json.dumps(data, ensure_ascii=False)\n            except Exception:\n                pretty = str(data)\n            logger.info(\"queue_update: %s\", pretty)\n            collector.push(data)\n    \n>       sio.connect(\n            server_url,\n            auth={\"robotId\": env_config.robot_id, \"token\": env_config.token, \"userId\": env_config.user_id},\n            transports=[\"polling\"],\n        )\n\nQA_PrismaX/Test_Env/conftest.py:90: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <socketio.client.Client object at 0x105007b00>\nurl = 'http://localhost:8081', headers = {}\nauth = {'robotId': 'arm1', 'token': 'QhZewTLifPlcp8I01ZFwCND7F1lKOolpFlbq1fdNA0s', 'userId': '1001047'}\ntransports = ['polling'], namespaces = ['/'], socketio_path = 'socket.io'\nwait = True, wait_timeout = 1, retry = False\n\n    def connect(self, url, headers={}, auth=None, transports=None,\n                namespaces=None, socketio_path='socket.io', wait=True,\n                wait_timeout=1, retry=False):\n        \"\"\"Connect to a Socket.IO server.\n    \n        :param url: The URL of the Socket.IO server. It can include custom\n                    query string parameters if required by the server. If a\n                    function is provided, the client will invoke it to obtain\n                    the URL each time a connection or reconnection is\n                    attempted.\n        :param headers: A dictionary with custom headers to send with the\n                        connection request. If a function is provided, the\n                        client will invoke it to obtain the headers dictionary\n                        each time a connection or reconnection is attempted.\n        :param auth: Authentication data passed to the server with the\n                     connection request, normally a dictionary with one or\n                     more string key/value pairs. If a function is provided,\n                     the client will invoke it to obtain the authentication\n                     data each time a connection or reconnection is attempted.\n        :param transports: The list of allowed transports. Valid transports\n                           are ``'polling'`` and ``'websocket'``. If not\n                           given, the polling transport is connected first,\n                           then an upgrade to websocket is attempted.\n        :param namespaces: The namespaces to connect as a string or list of\n                           strings. If not given, the namespaces that have\n                           registered event handlers are connected.\n        :param socketio_path: The endpoint where the Socket.IO server is\n                              installed. The default value is appropriate for\n                              most cases.\n        :param wait: if set to ``True`` (the default) the call only returns\n                     when all the namespaces are connected. If set to\n                     ``False``, the call returns as soon as the Engine.IO\n                     transport is connected, and the namespaces will connect\n                     in the background.\n        :param wait_timeout: How long the client should wait for the\n                             connection. The default is 1 second. This\n                             argument is only considered when ``wait`` is set\n                             to ``True``.\n        :param retry: Apply the reconnection logic if the initial connection\n                      attempt fails. The default is ``False``.\n    \n        Example usage::\n    \n            sio = socketio.Client()\n            sio.connect('http://localhost:5000')\n        \"\"\"\n        if self.connected:\n            raise exceptions.ConnectionError('Already connected')\n    \n        self.connection_url = url\n        self.connection_headers = headers\n        self.connection_auth = auth\n        self.connection_transports = transports\n        self.connection_namespaces = namespaces\n        self.socketio_path = socketio_path\n    \n        if namespaces is None:\n            namespaces = list(set(self.handlers.keys()).union(\n                set(self.namespace_handlers.keys())))\n            if '*' in namespaces:\n                namespaces.remove('*')\n            if len(namespaces) == 0:\n                namespaces = ['/']\n        elif isinstance(namespaces, str):\n            namespaces = [namespaces]\n        self.connection_namespaces = namespaces\n        self.namespaces = {}\n        if self._connect_event is None:\n            self._connect_event = self.eio.create_event()\n        else:\n            self._connect_event.clear()\n        real_url = self._get_real_value(self.connection_url)\n        real_headers = self._get_real_value(self.connection_headers)\n        try:\n            self.eio.connect(real_url, headers=real_headers,\n                             transports=transports,\n                             engineio_path=socketio_path)\n        except engineio.exceptions.ConnectionError as exc:\n            for n in self.connection_namespaces:\n                self._trigger_event(\n                    'connect_error', n,\n                    exc.args[1] if len(exc.args) > 1 else exc.args[0])\n            if retry:  # pragma: no cover\n                self._handle_reconnect()\n                if self.eio.state == 'connected':\n                    return\n            raise exceptions.ConnectionError(exc.args[0]) from None\n    \n        if wait:\n            while self._connect_event.wait(timeout=wait_timeout):\n                self._connect_event.clear()\n                if set(self.namespaces) == set(self.connection_namespaces):\n                    break\n            if set(self.namespaces) != set(self.connection_namespaces):\n                self.disconnect()\n>               raise exceptions.ConnectionError(\n                    'One or more namespaces failed to connect')\nE               socketio.exceptions.ConnectionError: One or more namespaces failed to connect\n\n/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/socketio/client.py:168: ConnectionError"}, "attachments": [{"name": "stderr", "source": "339ef3df-1c42-4dbb-9e05-f4bb60a848fd-attachment.txt", "type": "text/plain"}], "start": 1765175384091, "stop": 1765175384091, "uuid": "95223f8f-86ce-417a-ba88-8585105beef2", "historyId": "773b7531ed0647384aad5e3e2f50c0d7", "testCaseId": "773b7531ed0647384aad5e3e2f50c0d7", "fullName": "test_cases.test_tele_op#test_queue_update_event", "labels": [{"name": "feature", "value": "Tele-Op Queue"}, {"name": "story", "value": "Socket.IO queue_update"}, {"name": "tag", "value": "teleop"}, {"name": "parentSuite", "value": "test_cases"}, {"name": "suite", "value": "test_tele_op"}, {"name": "host", "value": "wanxins-MacBook-Pro.local"}, {"name": "thread", "value": "7496-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "test_cases.test_tele_op"}]}